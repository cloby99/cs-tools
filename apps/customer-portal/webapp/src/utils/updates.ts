// Copyright (c) 2026 WSO2 LLC. (https://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import { UPDATES_STATS } from "@constants/updatesConstants";
import type {
  ProductUpdateLevelsResponse,
  RecommendedUpdateLevelItem,
  UpdatesStats,
} from "@models/responses";

/** Pending update level row for display. */
export interface PendingUpdateLevelRow {
  updateLevel: number;
  updateType: "security" | "regular";
}

export const NULL_PLACEHOLDER = "--";

/**
 * Aggregates recommended update level data into summary statistics.
 *
 * @param {RecommendedUpdateLevelItem[] | undefined} data - The raw update level data.
 * @returns {UpdatesStats | undefined} The aggregated statistics.
 */
export const aggregateUpdateStats = (
  data: RecommendedUpdateLevelItem[] | undefined,
): UpdatesStats | undefined => {
  if (!data) {
    return undefined;
  }

  return data.reduce<UpdatesStats>(
    (acc, item) => {
      const installedRegular = item.installedUpdatesCount;
      const installedSecurity = item.installedSecurityUpdatesCount;
      const pendingRegular = item.availableUpdatesCount;
      const pendingSecurity = item.availableSecurityUpdatesCount;

      acc.totalUpdatesInstalled =
        (acc.totalUpdatesInstalled || 0) + installedRegular + installedSecurity;
      if (acc.totalUpdatesInstalledBreakdown) {
        acc.totalUpdatesInstalledBreakdown.regular += installedRegular;
        acc.totalUpdatesInstalledBreakdown.security += installedSecurity;
      }

      acc.totalUpdatesPending =
        (acc.totalUpdatesPending || 0) + pendingRegular + pendingSecurity;
      if (acc.totalUpdatesPendingBreakdown) {
        acc.totalUpdatesPendingBreakdown.regular += pendingRegular;
        acc.totalUpdatesPendingBreakdown.security += pendingSecurity;
      }

      acc.securityUpdatesPending =
        (acc.securityUpdatesPending || 0) + pendingSecurity;

      return acc;
    },
    {
      productsTracked: data.length,
      totalUpdatesInstalled: 0,
      totalUpdatesInstalledBreakdown: { regular: 0, security: 0 },
      totalUpdatesPending: 0,
      totalUpdatesPendingBreakdown: { regular: 0, security: 0 },
      securityUpdatesPending: 0,
    },
  );
};

/**
 * Gets the display value for a specific statistic ID from aggregated data.
 *
 * @param {UpdatesStats | undefined} aggregatedData - The aggregated statistics.
 * @param {keyof UpdatesStats} id - The ID of the statistic to retrieve.
 * @returns {string | number} The display value.
 */
export const getStatValue = (
  aggregatedData: UpdatesStats | undefined,
  id: keyof UpdatesStats,
): string | number => {
  if (!aggregatedData) {
    return NULL_PLACEHOLDER;
  }

  const val = aggregatedData[id];
  if (val === null || val === undefined) {
    return NULL_PLACEHOLDER;
  }

  if (typeof val === "object") {
    return NULL_PLACEHOLDER;
  }

  return val as string | number;
};

/**
 * Gets the tooltip text for a stat card, including breakdown info if applicable.
 *
 * @param {(typeof UPDATES_STATS)[number]} stat - The stat card definition.
 * @param {UpdatesStats | undefined} aggregatedData - The aggregated statistics.
 * @returns {string} The tooltip text.
 */
export const getStatTooltipText = (
  stat: (typeof UPDATES_STATS)[number],
  aggregatedData: UpdatesStats | undefined,
): string => {
  if (!aggregatedData) {
    return stat.tooltipText;
  }

  if (
    stat.id === "totalUpdatesInstalled" &&
    aggregatedData.totalUpdatesInstalledBreakdown
  ) {
    const { regular, security } = aggregatedData.totalUpdatesInstalledBreakdown;
    return `${stat.tooltipText} (${regular} Regular • ${security} Security)`;
  }

  if (
    stat.id === "totalUpdatesPending" &&
    aggregatedData.totalUpdatesPendingBreakdown
  ) {
    const { regular, security } = aggregatedData.totalUpdatesPendingBreakdown;
    return `${stat.tooltipText} (${regular} Regular • ${security} Security)`;
  }

  return stat.tooltipText;
};

/**
 * Computes pending update levels by matching productName and productBaseVersion
 * between recommended and product-update-levels responses.
 *
 * @param {RecommendedUpdateLevelItem} recommended - The recommended item (productName, productBaseVersion, endingUpdateLevel, recommendedUpdateLevel, etc.).
 * @param {ProductUpdateLevelsResponse} productLevels - The product update levels response.
 * @returns {PendingUpdateLevelRow[]} Pending levels with type (security/regular).
 */
export const getPendingUpdateLevels = (
  recommended: RecommendedUpdateLevelItem,
  productLevels: ProductUpdateLevelsResponse | undefined,
): PendingUpdateLevelRow[] => {
  if (!productLevels) {
    return [];
  }

  const product = productLevels.find(
    (p) => p.productName === recommended.productName,
  );
  if (!product) {
    return [];
  }

  const versionEntry = product.productUpdateLevels.find(
    (v) => v.productBaseVersion === recommended.productBaseVersion,
  );
  if (!versionEntry) {
    return [];
  }

  const { endingUpdateLevel, recommendedUpdateLevel } = recommended;
  const updateLevelSet = new Set(versionEntry.updateLevels);

  const pendingLevels: number[] = [];
  for (let level = endingUpdateLevel + 1; level <= recommendedUpdateLevel; level++) {
    if (updateLevelSet.has(level)) {
      pendingLevels.push(level);
    }
  }
  pendingLevels.sort((a, b) => a - b);

  const securityCount = recommended.availableSecurityUpdatesCount;

  return pendingLevels.map((level, index) => ({
    updateLevel: level,
    updateType:
      index < securityCount && securityCount > 0 ? "security" : "regular",
  }));
};
